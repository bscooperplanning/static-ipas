% This black box function can be used to evaluate methods that pass in a
% list of sensor locations, as generated by the grid_world structure
% See 'sensor_pos_blackbox_exmample.m' for an example that uses an
% information based approach to select sensor positions. 
%
% INPUTS
%   - n_sensors: number of sensors to be used in each iteration
%   - n_params: number of Gaussian basis functions that compose the field,
%   also setup as perfect square to evenly distribute around field.
%   Therefore: Total basis functions = n_params^2
%   - n_grid_dim: Assuming a square grid workspace, this is the row/column
%   size of the grid. So, total grid size = n_grid_row ^ 2
%   - SEED: true or false. If you want repeatble fields SEED = true
%
% OUTPUTS
%   - path_cost_incurred: the resulting path cost from our iterative
%   approach. Should always be >= path_cost_true
%   - path_cost_true: the path cost from planning with full information 
%   about the environment. Should be lower bound for path_cost_incurred. 

function [incurred_cost, expected_cost, path_cost_true, path_cost_var] = ...
    sensor_pos_to_info_rbf_blackbox(sensor_locations, threat_basis_data,...
    grid_world, sensor_noise)

%% TABULA RASA - the clean slate club
% clear variables; close all; clc
addpath('./routine/') % Add greedy sensor placement algorithms
% From J. Ranieri "Near Optimal Sensor Placement for Linear Inverse
% Problems", https://github.com/jranieri/OptimalSensorPlacement
threat_parameters_true = threat_basis_data.threat_parameters_true;

v_start	  = 1;
v_goal	  = grid_world.n_grid_points;

%% PATH PLANNING WITH TRUE THREAT (FOR COMPARISON)

threat_value_true = calc_threat_rbf(threat_basis_data, ...
	threat_parameters_true, grid_world.coordinates);

transition_cost = grid_world.adjacency;
for m1 = 1:grid_world.n_grid_points
	nhbrs	= find(grid_world.adjacency(m1, :));
	transition_cost(m1, nhbrs) = max(1E-3, threat_value_true(:, nhbrs)); % If exposure less than 0, take 0
end
search_data.adjacency_matrix= transition_cost;
search_data.adjacency_struct= [];
search_data.fcn_find_nhbr	= [];

search_data.v_start			= v_start; % start/goal verts set above sensor initial config
search_data.v_goal			= v_goal;
search_data.all_goal		= false;
% search_data.heuristic		= zeros(grid_world.n_grid_points, 1);
search_data.heuristic       = @min_threat_manhat_heur;
search_data.grid_world      = grid_world;

% [vertex_data_true, ~]	= astar(search_data);
[vertex_data_true, ~]	= astar_hfunc(search_data); % Uses heurstic function
opt_path_true = greedy_trace(search_data.v_start, search_data.v_goal, vertex_data_true);
% fprintf('Cost of true optimal path:\t%f\n', vertex_data_true(search_data.v_goal).d)

path_cost_true       		= sum(threat_value_true(opt_path_true(2:end)));

%=============     Batch Estimation of Threat Parameters     ============
identifiable_basis = identify_basis_close2sensor(sensor_locations, grid_world, threat_basis_data);
threat_basis_data_subset = threat_basis_data;
threat_basis_data_subset.basis_subset = identifiable_basis;
threat_basis_data_subset.basis_parameters.mean = ...
    threat_basis_data.basis_parameters.mean(:, identifiable_basis);
threat_basis_data_subset.n_threat_parameters = numel(identifiable_basis);
[tpe_mean, tpe_covar] = threat_estimate_rbf(sensor_locations, grid_world, ...
    threat_basis_data_subset, threat_parameters_true(identifiable_basis), sensor_noise);

% Reconstruct Field using only parameters with confidence
threat_value_estimate.mean	= calc_threat_rbf(threat_basis_data_subset, tpe_mean, grid_world.coordinates);

%===== Path planning
transition_cost_estimate = grid_world.adjacency;
for m1 = 1:grid_world.n_grid_points
    nhbrs	= find(grid_world.adjacency(m1, :));
    % intended to exclude negative vals? but erases connectivity for neg vals
    transition_cost_estimate(m1, nhbrs) = max( 1E-3, (threat_value_estimate.mean(:, nhbrs)) );
end
search_data.adjacency_matrix = transition_cost_estimate;

% [vertex_data, ~]= astar(search_data);
[vertex_data, ~]= astar_hfunc(search_data);

opt_path		= greedy_trace(search_data.v_start, search_data.v_goal, vertex_data);

expected_cost	= sum( max(0, threat_value_estimate.mean(opt_path(2:end))) );
incurred_cost	= sum(threat_value_true(opt_path(2:end)));

path_cost_var = path_cost_variance_rbf(opt_path, threat_basis_data,...
                        threat_basis_data_subset, grid_world, tpe_covar);

end
